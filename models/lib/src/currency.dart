import 'package:equatable/equatable.dart';

/// Валюта
///
/// К классу подмешивается [EquatableMixin], который реализует функционал
/// сравнения двух объектов на основании равенства значений определенных атрибутов
/// экземпляров класса. Так в данном случае две валюты считаются равными, если у
/// них равны коды валют. Список атрибутов, на основании которых определяется
/// равенство объектов возвращает геттер [props]
class Currency with EquatableMixin {
  /// Код валюты
  String code;

  /// Наименование валюты
  String name;

  /// Курс валюты
  num rate;

  /// Создает новый экземпляр валюты
  Currency({this.code, this.name, this.rate});

  /// Создает копию валюты
  ///
  /// Передача объектов происходит не по значению, а по ссылке. Часто возникает
  /// задача вернуть из функции объект с новым состоянием, при этом состояние
  /// исходного объекта должно остаться прежним, чтобы не нарушить другую логику.
  /// В этом случае создается копия объекта и изменение состояние делается у
  /// копии.
  factory Currency.from(Currency currency) {
    return Currency(
        code: currency.code, name: currency.name, rate: currency.rate);
  }

  /// Создает валюту на основании JSON-представления
  ///
  /// При чтении данных из какого-либо постоянного хранилища мы получаем данные
  /// в формате JSON. В Dart JSON хранится в виде `Map<String, dynamic>`. Данный
  /// конструктор используется, чтобы получать экземпляры валют на основании их
  /// JSON-представления.
  factory Currency.fromJson(Map<String, dynamic> json) {
    if (json == null) return null;
    return Currency(code: json['code'], name: json['name'], rate: json['rate']);
  }

  /// Возвращает JSON-представление объекта
  ///
  /// JSON-представление используется для передачи данных между клиентом и
  /// сервером, а также при сохранении данных в постоянное хранилище, например
  /// в БД.
  ///
  /// Наличие метода `toJson()` также позволяет упростить преобразование в JSON-
  /// формат сложных объектов, так как стандартный кодировщик `json.encode`
  /// автоматически вызывает метод `toJson` (если он есть) для объектов, которые
  /// он не знает как перекодировать в JSON.
  Map<String, dynamic> toJson() {
    return {'code': code, 'name': name, 'rate': rate};
  }

  @override
  String toString() =>
      '(Currency: ${code ?? ''}, ${name ?? ''}, ${rate ?? ''})';

  @override
  List<Object> get props => [code];
}
